{
  "en": {
    "nav": {
      "home": "Home",
      "games": "Games",
      "projects": "Projects",
      "contact": "Contact"
    },
    "header": {
      "name": "Alex Ceberio Hernandez",
      "subtitle": "RTIS programmer and Game Developer",
      "about": "About me",
      "about_text": "Hi, my name is Alex. I'm a C++ programmer with a focus on game programming, tools development, and AI development for games. I graduated from DigiPen Institute of Technology Bilbao with a Bachelor's degree in Computer Science in Real-Time Interactive Simulations (RTIS).<br><br>In this page, you can explore the projects and games I’ve worked on."
    },
    "games_info": {
      "juegos_estudiante": "Student games",
      "proyectos_estudiante" : "Student projects",
      "numbra":"A 3D puzzle and exploration game, where you travel a mysterious world and avoid being seen by the various enemies that will try to hunt you.",
      "crashNBurn":"Low poly space-themed racing game with highly customizable ships that provide you with different tools to hamper your rivals’ progress or gain a more direct advantage yourself.",
      "animaSilvarum":"A 2D action-exploration adventure set in a colorful world full of mysteries and enigmatic secrets.",
      "antSquad":"A top-down 2D reverse tower defence game where the player controls a nest of ants.",
      "ithangi":"A 2D top-down shooter where you control a tank that will fight against other enemy tanks.",
      "popThePops":"Race against your old enemy and bounce around to beat them on frenetic obstacle courses. Get the highest score to win!"
    },
    "details": {
      "fechaSalida": "Release date:",
      "tamañoEquipo": "Team Size:",
      "idioma": "Language:",
      "motor": "Engine:",
      "programadores": "programmers",
      "artistas": "artists",
      "descargar": "Download",
      "rol": "My role"
    },
    "meses":{
      "enero":"January",
      "febrero":"February",
      "marzo":"March",
      "abril":"April",
      "mayo":"May",
      "junio":"June",
      "julio":"July",
      "agosto":"August",
      "septiembre":"September",
      "octubre":"October",
      "noviembre":"Noverber",
      "diciembre":"December"
    },
    "animaSilvarum_data": {
      "motor": " 2D game engine done from scratch in C++",
      "description": "A 2D action-exploration adventure set in a colorful world full of mysteries and enigmatic secrets. Take control of Héctor, an apprentice scribe who is unexpectedly thrown into a criminal conspiracy involving robbery and a kidnapping. Investigate unexplored territories as you venture outside your village and into the uncharted realms beyond the forest. Defeat mysterious enemies, solve engaging puzzles, and recover what is yours by discovering the truth behind the crimes!",
      "rol": "I worked for this game at my second year at DigiPen, with the role of Gameplay programmer. The most relevant task I worked on where the following:",
      "rol1":"Implemented the collision and physics systems.",
      "rol2":"Created the level editor using ImGui and ImGuizmo, implementing the basics of object creation and deletion, component management, scene creation and loading, as well as many tools to help the artists better create levels, like ctrl z, vertex snapping or atlas loading.",
      "rol3":"Implemented text rendering and translation tools, including managing characters not present on the english language.",
      "rol4":"For gameplay, I worked on the quest system, final boss, and UI work like the menus and game UI."
    },
    "numbra_data":{
      "motor": "Unreal Engine 5",
      "description" : "A 3D puzzle and exploration game, inspired by the likes of Little Nightmares or Inside.", 
      "lore" :"In a desolate and ominous world, a young girl faces dark creatures that lurk in every shadow. With each step, the danger grows. But there is only one rule: stay awake.",
      "rol":"I worked for this game at my forth year at DigiPen, with the role of Gameplay programmer. My most relevant taks I worked on where all the enemies in the game, from which I used and learned a good variety of tools Unreal Engine provides, such as their AI system with behaviour trees, level sequences and state machies for the animations."
    },
    "crashNBurn_data":{
      "motor": "3D game engine done from scratch in C++",
      "description": "Low poly space-themed racing game with highly customizable ships that provide you with different tools to hamper your rivals’ progress or gain a more direct advantage yourself. You can play with up to 3 other frinds locally",
      "rol" :"I worked for this game at my third year at DigiPen, with the role of Gameplay programmer. The most relevant task I worked on where the following:",
      "rol1" :"Implemented the input event system for keyboard and mouse using SDL",
      "rol2" :"Created the editor using ImGui and ImGuizmo, implementing the basics of object creation and deletion, component management, scene creation and loading and more things.",
      "rol3_1" :"Develped the AIs of the game, for which I used the ",
      "rol3_2" : "algorithm entirely on my own."
    },
    "antSquad_data":{
      "motor": "2D engine provided by DigiPen",
      "description":"Ant Squad is a Top-down 2D reverse tower defence game where the player controls a nest of ants, and he has to send them throughout the map, so they reach to the end of the enemy base. The player will have three different type of units and will be able to send them through three different paths. At the end of the map there is the final boss and alongside the three paths there are enemies to delay the advance of the player.",
      "rol":"This was my second game I worked on my first year at DigiPen, with the role of Game Programmer, altough I also worked a lot on the design of the game. The most relevant task I worked on where the following:",
      "rol1":"Design of the game mechanics and balancing the game economy system.",
      "rol2":"Programmed the power ups of the player.",
      "rol3":"Made the UI of the player and enemy units, the power up and path selection buttons."
    },
    "ithangi_data":{
      "description":"The game is a 2D top-down shooter where you control a tank that will fight against other enemy tanks. There are 3 different levels, and the objective is unique to each one of them, as well as the terrains, which have unique mechanics. You can also play with a different tank depending on the level. The thematic of the game is based in battles of the second world war and their tanks.",
      "rol":"This was my first game I worked on at DigiPen, with the role of Game Designer. The most relevant task I worked on where the following:",
      "rol1":"Design of the game mechanics, enemy types and level design.",
      "rol2":"Programmed the player movement and main mechanics like shooting and power ups.",
      "rol3":"Made the UI of the player and menus."
    },
    "popThePops_data":{
      "description": "A 2-player local versus 2.5D platformer (3D models with 2D gameplay mechanics), where you race to the goal while inside a bubble. It was made for 2025's Global Game Jam, made in less than 3 days, with the topic being \"Bubbles\", and it won the prize for the best user experience."
    },
    "GOAP_data":{
      "description1":"Goal-Oriented-Action-Planning (GOAP for short) is a declarative game AI architecture created by Jeff Orkin for the game F.E.A.R, designed for real-time control of autonomous character behavior in games. Compared with simpler architectures such as State Machines or Behaviour Trees, GOAP provides far better code scalability and flexibility while on development, avoiding the labyrinthic transitions that can end up being generated. This architecture gives game characters the ability to select goals and make plans to achieve those goals based on the state of the environment and available resources.",
      "description2":"This was the topic I chose for the final project of CS380 (a course focused on AI development for videogames), where I researched the algorithm and made a demo implementing the algorithm, written in C++ from scratch. The demo has 3 different agents (a rabbit, wolf and bear), where each will try to survive by escaping, searching food or fighting, and satisfy their goals.",
      "description3_1":"You can download the reseach paper ",
      "description3_2" :"here"
    },
    "CBS_data":{
      "title1":"As part of one of my student games, ",
      "title2":", I was tasked with making the AI for the rivals you would race against, and the algorithm I chose to implement for this task is called Context Based Steering.",
      "algorithm":"The algorithm",
      "algorithm1" :"Our first step is to define how our agent will get the \"Context\" part. For this, our agents (in my case, the rival racers) will have a list of rays all around its body. You can choose the amount of rays you see fit for your situation, but for my game, I chose 16 rays. These rays will represent the agent’s interests (the way to the goal),  as well as the way to detect dangers (walls, obstacles, other players...), and are what will define the context of the AI’s environment. With this, we can define how the agent will select in which direction to steer at any moment.",
      "algorithm2":"First, the interest will be read from where the agent is at the moment, I'll explain later how we find this value. Each ray is given a strenght value depending on how close it is to the interest ray. We then check for every ray if there's an obstacle within x distance of the agent, and we store this in each ray's data. By combining the interest and danger of each ray, we can discard the rays that have a danger, then sum the remaining rays and obtain our desired direction, pointing away from any obstacle.",
      "interest":"The interest",
      "interest1":"This will vary depending on what your goal is. If, for example, you want an AI that will follow the player, the interest would be a vector pointing from the agent to the player. You can even add multiple interests and then select one based on the environment or even luck. ",
      "interest2":"For my game, I separated the track into chunks of varying sizes and added a direction at each. Most of the time, his direction would point forward with relation to that point of the track, but in some cases I would change it if I wanted the AIs to start steering earlier, or avoid going through shortcuts.",
      "code":"The code",
      "code1":"This is how I chose to represent the data, as an array of custom directions, which will store the direction vector, its interest factor, if there’s a danger, and the danger factor, to know how close the danger is.",
      "code2":"The rays are then computed to all be around the player, forming a circle. (Also, although I'm using 3D vectors to store the data, since verticality ended up not being necessary, the vertical axis is not used for any computation.)",
      "code3":"To detect the dangers of the track, we need to define what the dangers actually are. As mentioned earlier, my approach consists on subdividing the track into chunks/waypoints. Each waypoint will have a quadrilateral form, with it's shape determined by the left and right position of the current waypoint and the next. The left wall of the track is thus defined by the current left and next left positions, and the same for the right wall. Also, we store the next waypoint in an array as to handle tracks with multiple paths. A list of obstacles is also there, to mark static dangers within the chunk. ",
      "code4":"Each frame, the agent will check if it has advanced waypoints by computing the dot product between the forward vector of the next waypoint and the vector from the left position to the player. If dot product is bigger than 0, we advance to the next waypoint.",
      "code5":"In the update of the AI, we need 3 main functions to determine the steer direction. We'll start with the interest function.",
      "code6":"As mentioned before, we get our desired direction by whathever method we are using. Since I already have manually added them for each waypoint, we get the direction for the one we are in. Remember that this vector should be normalized. Then for each ray, we compute the dot product between the desired direction and the ray's direction. We will clamp to remove negative values and store them. ",
      "code7":"Now we go to the danger function. We will go for each ray, checking if the ray intersects any wall. For the intersection test, I chose to do a 2D line-line check, since our ray will have a fixed length and turn into a line, and the walls are also lines with the waypoints method I have. This function will give us the intersection point in a range [0,1]. For each direction, you should also check the t values of the next neighbours (checking between 3 to 5 is enough) and get the smallest, so the AI does not ignore walls outside his waypoint.",
      "code8":"Finally, to decide the final direction, we reduce each ray’s interest by multiplying it with its danger value if there was a collision in that direction, we sum all the direction vectors multiplied by their corresponding interest value, and we normalize the resulting vector."
    }
  },
  "es": {
    "nav": {
      "home": "Inicio",
      "games": "Juegos",
      "projects": "Proyectos",
      "contact": "Contacto"
    },
    "header": {
      "name": "Alex Ceberio Hernández",
      "subtitle": "Programador RTIS y Desarrollador de Juegos",
      "about": "Sobre mí",
      "about_text": "Hola, me llamo Alex. Soy programador C++ con un enfoque en programación de videojuegos, desarrollo de herramientas y desarrollo de IA para juegos. Me gradué en DigiPen Institute of Technology Bilbao con el Grado en Informática en Simulaciones Interactivas en Tiempo Real (RTIS).<br><br>En esta página, puedes explorar los proyectos y videojuegos en los que he trabajado."
    },
    "games_info": {
      "juegos_estudiante": "Juegos de estudiante",
      "proyectos_estudiante" : "Proyectos de estudiante",
      "numbra":"Un juego 3D de puzles y exploración, en el cual viajaras por un misterioso mundo evitando ser visto por los varios enemigos que tratarán de cazarte.",
      "crashNBurn":"Un juego de carreras low poly con temáticas del espacio, con naves customizables con habilidades únicas, con las cuales molestar a tus rivales o conseguir ventajas propias.",
      "animaSilvarum":"Un juego de acción y exploración 2D, en un mundo lleno de colores, misterios y secretos enigmáticos.",
      "antSquad":"Un tower defense inverso 2D en el cual controlas una colonia de hormigas.",
      "ithangi":"Un top-down shooter en 2D donde controlas un tanque y luchas contra otros tanques.",
      "popThePops":"Compite contra tu viejo rival, bota y rebota para superar obstaculos en frenéticas carreras. ¡Consigue la puntuación más alta para ganar!"
    },
    "details": {
      "fechaSalida": "Fecha de salida:",
      "tamañoEquipo": "Tamaño del equipo:",
      "idioma": "Idioma:",
      "motor": "Motor:",
      "programadores": "programadores",
      "artistas": "artistas",
      "descargar": "Descargar",
      "rol": "Mi rol"
    },
    "meses":{
      "enero":"de enero",
      "febrero":"de febrero",
      "marzo":"de marzo",
      "abril":"de abril",
      "mayo":"de mayo",
      "junio":"de junio",
      "julio":"de julio",
      "agosto":"de agosto",
      "septiembre":"de septiembre",
      "octubre":"de octubre",
      "noviembre":"de noviembre",
      "diciembre":"de diciembre"
    },
    "animaSilvarum_data": {
      "motor": "2D programado desde cero en C++",
      "description": "Una aventura de acción y exploración en 2D ambientada en un mundo colorido, lleno de misterios y secretos enigmáticos. Toma el control de Héctor, un aprendiz de escriba que es arrastrado inesperadamente a una conspiración criminal que involucra un robo y un secuestro. Investiga territorios inexplorados mientras te aventuras fuera de tu aldea y hacia los reinos desconocidos más allá del bosque. ¡Derrota a enemigos misteriosos, resuelve acertijos desafiantes y recupera lo que es tuyo descubriendo la verdad detrás de los crímenes!",
      "rol": "Trabajé en este juego durante mi segundo año en DigiPen, con el rol de programador de jugabilidad. Las tareas más relevantes en las que trabajé fueron las siguientes:",
      "rol1":"Implementé el sistema de colisiones y físicas.",
      "rol2":"Creé el editor de niveles usando ImGui e ImGuizmo, implementando las herramientas básicas de creación y destrucción de objetos,controlador de componentes, creación y cargado de escenas, asi como otras herramientas para ayudar a los artistas en la creacion de niveles, como el ctrl z, vertex snapping o cargar atlases.",
      "rol3":"Implementé herramientas de traducción y renderizado de texto, incluyendo la gestión de caracteres exclusivos no presentes en el inglés",
      "rol4":"Tema gameplay, trabajé en el sistema de misiones, IA del jefe final, y todo el UI del menu y gameplay."
    },    
    "numbra_data":{
      "motor": "Unreal Engine 5",
      "description" : "Un juego de exploración y puzzles en 3D, inspirado en juegos del estilo de Little Nightmares o Inside.", 
      "lore" :"En un mundo desolado y ominoso, una joven enfrenta a criaturas oscuras que acechan en cada sombra. Con cada paso, el peligro aumenta. Pero solo hay una regla: mantenerse despierta.",
       "rol":"Trabajé en este juego en mi cuarto año en DigiPen, con el rol de Gameplay Programmer. Mis tareas más relevantes fueron el desarrollo de todos los enemigos del juego, en lo cual utilicé y aprendí una buena variedad de herramientas que ofrece Unreal Engine, como su sistema de IA con Behaviour Trees, secuencias de nivel y máquinas de estados para las animaciones."
    },
    "crashNBurn_data":{
      "motor": "3D programado desde cero en C++",
      "description": "Un juego de carreras low poly con temáticas del espacio, con naves customizables con habilidades únicas, con las cuales molestar a tus rivales o conseguir ventajas propias. Puedes jugar con hasta 3 amigos de manera local.",
      "rol" :"Trabajé en este juego en mi tercer año en DigiPen como programador de Gameplay. Las tareas más relevantes en las que trabajé fueron las siguientes:",
      "rol1" :"Implementé el sistema de eventos de inputs para teclado y raton usando SDL.",
      "rol2" :"Creé el editor usando las librerías dee ImGui e ImGuizmo, implementando las herramientas básicas de creación y destrucción de objetos, controlador de componentes, creación y cargado de escenas y más cosas",
      "rol3_1" :"Creé las IAs del juego, para lo cual implementé el algoritmo de",
      "rol3_2" : " yo entero."
    },
    "antSquad_data":{
      "motor": "2D proporcionado por DigiPen",
      "description":"Ant Squad es un tower defense inverso top-down en 2D, donde el jugador controla un nido de hormigas y debe enviarlas a través del mapa para que lleguen hasta la base enemiga. El jugador tendrá tres tipos diferentes de unidades y podrá enviarlas por tres caminos distintos. Al final del mapa se encuentra el jefe final, y a lo largo de los tres caminos hay enemigos que intentarán retrasar el avance del jugador.",
      "rol":"Este fue mi segundo juego en el que trabajé durante mi primer año en DigiPen, con el rol de Game Programmer, aunque también participé mucho en el diseño del juego. Las tareas más relevantes en las que trabajé fueron las siguientes:",
      "rol1":"Diseñé las mecanicas del juego y balanceé el sistema de economia del juego.",
      "rol2":"Programé los power ups del jugador.",
      "rol3":"Creé el UI del jugador y unidades enemigas, asi como los botones de los menus y power ups."
    },
    "ithangi_data":{
      "description":"Ithangi es un top-down shooter en 2D donde tendrás que combatir contra tanques enemigos con tu propio tanque. Tiene 3 niveles jugables, y el objetivo en cada uno será diferente, asi como el los terrenos, que tendrán mecánicas diferentes. Además, en cada nivel usaras un tanque diferente. El juego,sus niveles y tanques estan basados en batallas de la segunda guerra mundial.",
      "rol":"Este fué el primer juego en el que trabaje en DigiPen, con el rol de Game Designer. Las tareas más relevantes en las que trabajé fueron las siguientes:",
      "rol1":"Diseñé las mecánicas del juegos, los tipos de enemigos y el diseño de niveles.",
      "rol2":"Programé el movimiento del tanque del jugador y las mecánicas principales, como el disparo y los power ups",
      "rol3":"Creé el UI del player y los menus."
    },
    "popThePops_data":{
      "description": "Un juego de plataformas 2.5D (modelos 3D con mecánicas de juego en 2D) para 2 jugadores en modo local, donde compites por llegar a la meta mientras estás dentro de una burbuja. Fue desarrollado para la Global Game Jam 2025 en menos de 3 días, con la temática \"Burbujas\", y ganó el premio a la mejor experiencia de usuario."
    },
    "GOAP_data":{
      "description1":"Goal-Oriented-Action-Planning (GOAP, por sus siglas en inglés) es una arquitectura de IA declarativa para juegos creada por Jeff Orkin para el juego F.E.A.R, diseñada para el control en tiempo real del comportamiento autónomo de los personajes en los juegos. Comparada con arquitecturas más simples, como las Máquinas de Estados o los Behaviour Trees, GOAP ofrece una escalabilidad y flexibilidad de código mucho mayores durante el desarrollo, evitando las transiciones laberínticas que podrían generarse. Esta arquitectura permite a los personajes del juego seleccionar objetivos y elaborar planes para alcanzarlos en función del estado del entorno y los recursos disponibles.",
      "description2":"Este fue el tema que elegí para el proyecto final de CS380 (un curso enfocado en el desarrollo de IA para videojuegos), donde investigué el algoritmo y creé una demo implementándolo desde cero en C++. La demo tiene 3 agentes diferentes (un conejo, un lobo y un oso), donde cada uno intentará sobrevivir escapando, buscando comida o luchando, y cumplir sus objetivos.",
      "description3_1":"Puedes descargar el documento de investigación ",
      "description3_2" :"aqui"
    },
    "CBS_data": {
    "title1": "Como parte de uno de mis juegos de estudiante, ",
    "title2": ", me encargaron hacer la IA para los rivales contra los que competirías en la carrera, y el algoritmo que elegí implementar para esta tarea se llama Context Based Steering.",
    "algorithm": "El algoritmo",
    "algorithm1": "Nuestro primer paso es definir cómo nuestro agente obtendrá la parte de \"Contexto\". Para esto, nuestros agentes (en mi caso, los corredores rivales) tendrán una lista de rayos alrededor de su cuerpo. Puedes elegir la cantidad de rayos que consideres adecuada para tu situación, pero para mi juego elegí 16 rayos. Estos rayos representarán los intereses del agente (el camino hacia la meta), así como la forma de detectar peligros (paredes, obstáculos, otros jugadores...), y son lo que definirá el contexto del entorno de la IA. Con esto, podemos definir cómo el agente seleccionará en qué dirección girar en cada momento.",
    "algorithm2": "Primero, se leerá el interés desde donde esté el agente en ese momento, luego explicaré cómo encontramos este valor. A cada rayo se le asigna un valor de fuerza dependiendo de qué tan cerca esté del rayo de interés. Luego verificamos para cada rayo si hay un obstáculo dentro de una distancia x del agente, y almacenamos esto en los datos de cada rayo. Combinando el interés y el peligro de cada rayo, podemos descartar los rayos que detecten un peligro, luego sumamos los rayos restantes y obtenemos nuestra dirección deseada, apuntando lejos de cualquier obstáculo.",
    "interest": "El interés",
    "interest1": "Esto variará dependiendo de cuál sea tu objetivo. Si, por ejemplo, quieres una IA que siga al jugador, el interés sería un vector que apunte desde el agente hacia el jugador. Incluso puedes añadir múltiples intereses y luego seleccionar uno según el entorno o incluso al azar.",
    "interest2": "Para mi juego, dividí la pista en segmentos de varios tamaños y añadí una dirección en cada uno. La mayor parte del tiempo, la dirección apunta hacia adelante en relación con ese punto de la pista, pero en algunos casos la cambiaría si quería que las IAs empezaran a girar antes, o para evitar que tomaran atajos.",
    "code": "El código",
    "code1": "Así fue como elegí representar los datos, como un vector de direcciones personalizadas, que almacenará el vector de dirección, su factor de interés, si hay un peligro, y el factor de peligro, para saber qué tan cerca está el peligro.",
    "code2": "Luego los rayos se calculan de manera que estén alrededor del jugador, formando un círculo. (Cabe recalcar que, aunque estoy usando vectores 3D para almacenar los datos, dado que la verticalidad no terminó siendo necesaria, el eje vertical no se usa para ningún cálculo).",
    "code3": "Para detectar los peligros de la pista, necesitamos definir qué son en realidad los peligros. Como mencioné antes, mi enfoque consiste en subdividir la pista en segmentos/waypoints. Cada segmento tendrá una forma cuadrilátera, con su forma determinada por la posición izquierda y derecha del waypoint actual y el siguiente. La pared izquierda de la pista esta formada por la posición izquierda actual y la siguiente izquierda, y lo mismo para la pared derecha. Además, almacenamos el siguiente segmento en un vector para pistas con múltiples caminos. También hay una lista de obstáculos para marcar peligros estáticos dentro del segmento.",
    "code4": "En cada frame, el agente verificará si ha avanzado puntos de control calculando el dot product entre el vector hacia adelante del siguiente waypoint y el vector desde la posición izquierda hasta el jugador. Si el dot product es mayor que 0, avanzamos al siguiente waypoint.",
    "code5": "En el update de la IA, necesitamos 3 funciones principales para determinar la dirección del giro. Comenzaremos con la función de interés.",
    "code6": "Como se mencionó antes, obtenemos nuestra dirección deseada mediante el método que estemos usando. Como ya las añadí manualmente para cada waypoint , obtenemos la dirección del segmento en el que estamos. Recuerda que este vector debe estar normalizado. Luego, para cada rayo, calculamos el dot product entre la dirección deseada y la dirección del rayo. Lo limitamos para eliminar valores negativos y los almacenamos.",
    "code7": "Ahora vamos a la función de peligro. Iremos rayo por rayo, verificando si el rayo intersecta alguna pared. Para la prueba de intersección, elegí hacer una comprobación línea-línea en 2D, ya que nuestro rayo tendrá una longitud fija y se convertirá en una línea, y las paredes también son líneas con el método de puntos de control que tengo. Esta función nos dará el punto de intersección en un rango [0,1]. Para cada dirección, también deberías verificar los valores t de los siguientes vecinos (con comprobar los siguientes tres o cuatro vale) y obtener el más pequeño, para que la IA no ignore paredes fuera de su segmento.",
    "code8": "Finalmente, para decidir la dirección final, reducimos el interés de cada rayo multiplicándolo por su valor de peligro si hubo una colisión en esa dirección, sumamos todos los vectores de dirección multiplicados por su valor de interés correspondiente, y normalizamos el vector resultante."
  }

  }
}